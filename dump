--- Contents of file: D:\Projects\dev\keshon\bvc\internal\repo\list.go --- 
package repo

import (
	"fmt"
	"path/filepath"

	"app/internal/config"
	"app/internal/repo"
	"app/internal/storage/snapshot"
	"app/internal/util"
)

// BlockInfo holds metadata about a block in the repository
type BlockInfo struct {
	Size     int64
	Files    map[string]struct{}
	Branches map[string]struct{}
}

// ListAllBlocks returns a map[hash] of BlockInfo for all blocks in all branches.
// If allHistory is true, collects blocks from all commits in all branches; otherwise only latest commits.
func ListAllBlocks(allHistory bool) (map[string]*BlockInfo, error) {
	// Open the repository context
	r, err := repo.OpenAt(config.RepoDir)
	if err != nil {
		return nil, fmt.Errorf("failed to open repository: %w", err)
	}

	branches, err := r.ListBranches()
	if err != nil {
		return nil, err
	}

	blocks := make(map[string]*BlockInfo)

	for _, b := range branches {
		var commitIDs []string
		if allHistory {
			commitIDs, err = r.AllCommitIDs(b.Name)
			if err != nil {
				return nil, err
			}
		} else {
			last, err := r.GetLastCommitID(b.Name)
			if err != nil {
				return nil, err
			}
			if last != "" {
				commitIDs = []string{last}
			}
		}

		for _, commitID := range commitIDs {
			var commit core.Commit
			if err := util.ReadJSON(filepath.Join(config.CommitsDir, commitID+".json"), &commit); err != nil {
				continue
			}

			var fs snapshot.Fileset
			if err := util.ReadJSON(filepath.Join(config.FilesetsDir, commit.FilesetID+".json"), &fs); err != nil {
				continue
			}

			for _, f := range fs.Files {
				for _, blk := range f.Blocks {
					info, ok := blocks[blk.Hash]
					if !ok {
						info = &BlockInfo{
							Size:     blk.Size,
							Files:    map[string]struct{}{},
							Branches: map[string]struct{}{},
						}
						blocks[blk.Hash] = info
					}
					info.Files[f.Path] = struct{}{}
					info.Branches[b.Name] = struct{}{}
				}
			}
		}
	}

	return blocks, nil
}

// CountBlocks returns the total number of blocks in all branches.
// If allHistory is true, counts blocks from all commits; otherwise only latest commits.
func CountBlocks(allHistory bool) (int, error) {
	// Open the repository context
	r, err := repo.OpenAt(config.RepoDir)
	if err != nil {
		return 0, fmt.Errorf("failed to open repository: %w", err)
	}

	branches, err := r.ListBranches()
	if err != nil {
		return 0, err
	}
	hashes := map[string]struct{}{}

	for _, b := range branches {
		var commitIDs []string
		if allHistory {
			commitIDs, err = r.AllCommitIDs(b.Name)
			if err != nil {
				return 0, err
			}
		} else {
			last, err := r.GetLastCommitID(b.Name)
			if err != nil {
				return 0, err
			}
			if last != "" {
				commitIDs = []string{last}
			}
		}

		for _, commitID := range commitIDs {
			var commit core.Commit
			if err := util.ReadJSON(fmt.Sprintf("%s/%s.json", config.CommitsDir, commitID), &commit); err != nil {
				continue
			}
			var fs snapshot.Fileset
			if err := util.ReadJSON(fmt.Sprintf("%s/%s.json", config.FilesetsDir, commit.FilesetID), &fs); err != nil {
				continue
			}
			for _, e := range fs.Files {
				for _, b := range e.Blocks {
					hashes[b.Hash] = struct{}{}
				}
			}
		}
	}

	return len(hashes), nil
}
 
--- Contents of file: D:\Projects\dev\keshon\bvc\internal\repo\verify.go --- 
package repo

import (
	"app/internal/progress"
	"app/internal/storage"
	"os"

	"app/internal/storage/block"

	"app/internal/util"
	"fmt"
)

// VerifyBlocks checks all blocks in repository and shows a progress bar.
// Returns error if any block is missing/damaged.
func VerifyBlocks(allHistory bool) error {
	out, errCh := VerifyBlocksStream(allHistory)

	totalBlocks, err := CountBlocks(allHistory)
	if err != nil {
		return err
	}

	bar := progress.NewProgress(totalBlocks, "Checking blocks")
	defer bar.Finish()

	for bc := range out {
		bar.Increment()
		if bc.Status != block.OK {
			return fmt.Errorf("block %s is missing or damaged", bc.Hash)
		}
	}

	if err := <-errCh; err != nil {
		return err
	}
	return nil
}

// VerifyBlocksStream streams block verification results.
func VerifyBlocksStream(allHistory bool) (<-chan block.BlockCheck, <-chan error) {
	out := make(chan block.BlockCheck, 128)
	errCh := make(chan error, 1)

	go func() {
		defer close(out)
		defer close(errCh)

		// Open the repo and access its storage manager
		mgr, err := storage.NewManager(".bvc"), error(nil)
		if _, statErr := os.Stat(".bvc"); os.IsNotExist(statErr) {
			errCh <- fmt.Errorf("repository not initialized (missing .bvc)")
			return
		}

		// Collect all referenced blocks
		blocks, err := ListAllBlocks(allHistory)
		if err != nil {
			errCh <- err
			return
		}

		// Prepare hash set
		hashes := make(map[string]struct{}, len(blocks))
		for h := range blocks {
			hashes[h] = struct{}{}
		}

		// Use the block subsystem under the manager
		verifyOut := mgr.Blocks.Verify(hashes, util.WorkerCount())

		for bc := range verifyOut {
			ref := blocks[bc.Hash]
			bc.Files = util.SortedKeys(ref.Files)
			bc.Branches = util.SortedKeys(ref.Branches)
			out <- bc
		}
	}()

	return out, errCh
}
 
